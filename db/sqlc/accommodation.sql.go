// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: accommodation.sql

package db

import (
	"context"
)

const createAccommodation = `-- name: CreateAccommodation :one
INSERT INTO Accommodation (
  accommodation_name, pernight, accommodation_type, accommodation_description, webaddress,  emailaddress, phonenumber, area
) VALUES (
  $1, $2, $3, $4,$5, $6, $7, $8
)
RETURNING id, accommodation_name, pernight, accommodation_type, accommodation_description, webaddress, emailaddress, phonenumber, area
`

type CreateAccommodationParams struct {
	AccommodationName        string `db:"accommodation_name"`
	Pernight                 int64  `db:"pernight"`
	AccommodationType        int64  `db:"accommodation_type"`
	AccommodationDescription string `db:"accommodation_description"`
	Webaddress               string `db:"webaddress"`
	Emailaddress             string `db:"emailaddress"`
	Phonenumber              string `db:"phonenumber"`
	Area                     int64  `db:"area"`
}

// input: name, pernight, accommodation_type, accommodation_description, webaddress, emailadddress, phonenumber, area
// output :one
func (q *Queries) CreateAccommodation(ctx context.Context, arg CreateAccommodationParams) (Accommodation, error) {
	row := q.db.QueryRowContext(ctx, createAccommodation,
		arg.AccommodationName,
		arg.Pernight,
		arg.AccommodationType,
		arg.AccommodationDescription,
		arg.Webaddress,
		arg.Emailaddress,
		arg.Phonenumber,
		arg.Area,
	)
	var i Accommodation
	err := row.Scan(
		&i.ID,
		&i.AccommodationName,
		&i.Pernight,
		&i.AccommodationType,
		&i.AccommodationDescription,
		&i.Webaddress,
		&i.Emailaddress,
		&i.Phonenumber,
		&i.Area,
	)
	return i, err
}

const deleteAccommodation = `-- name: DeleteAccommodation :exec
DELETE FROM Accommodation
WHERE id = $1
`

func (q *Queries) DeleteAccommodation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAccommodation, id)
	return err
}

const getAccommodation = `-- name: GetAccommodation :one
SELECT id, accommodation_name, pernight, accommodation_type, accommodation_description, webaddress, emailaddress, phonenumber, area FROM Accommodation
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAccommodation(ctx context.Context, id int64) (Accommodation, error) {
	row := q.db.QueryRowContext(ctx, getAccommodation, id)
	var i Accommodation
	err := row.Scan(
		&i.ID,
		&i.AccommodationName,
		&i.Pernight,
		&i.AccommodationType,
		&i.AccommodationDescription,
		&i.Webaddress,
		&i.Emailaddress,
		&i.Phonenumber,
		&i.Area,
	)
	return i, err
}

const getAccommodationByLocation = `-- name: GetAccommodationByLocation :many
SELECT id, accommodation_name, pernight, accommodation_type, accommodation_description, webaddress, emailaddress, phonenumber, area FROM Accommodation
WHERE area= $1
`

func (q *Queries) GetAccommodationByLocation(ctx context.Context, area int64) ([]Accommodation, error) {
	rows, err := q.db.QueryContext(ctx, getAccommodationByLocation, area)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Accommodation{}
	for rows.Next() {
		var i Accommodation
		if err := rows.Scan(
			&i.ID,
			&i.AccommodationName,
			&i.Pernight,
			&i.AccommodationType,
			&i.AccommodationDescription,
			&i.Webaddress,
			&i.Emailaddress,
			&i.Phonenumber,
			&i.Area,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccommodation = `-- name: ListAccommodation :many
SELECT id, accommodation_name, pernight, accommodation_type, accommodation_description, webaddress, emailaddress, phonenumber, area FROM Accommodation
ORDER BY accommodation_name
LIMIT $1
OFFSET $2
`

type ListAccommodationParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListAccommodation(ctx context.Context, arg ListAccommodationParams) ([]Accommodation, error) {
	rows, err := q.db.QueryContext(ctx, listAccommodation, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Accommodation{}
	for rows.Next() {
		var i Accommodation
		if err := rows.Scan(
			&i.ID,
			&i.AccommodationName,
			&i.Pernight,
			&i.AccommodationType,
			&i.AccommodationDescription,
			&i.Webaddress,
			&i.Emailaddress,
			&i.Phonenumber,
			&i.Area,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccommodation = `-- name: UpdateAccommodation :one
UPDATE Accommodation
  set  accommodation_name = $2,
 pernight   = $3,
 Accommodation_type = $4,
 webaddress = $5,
 emailaddress = $6,
 phonenumber = $7,
 area = $8

WHERE id = $1
RETURNING id, accommodation_name, pernight, accommodation_type, accommodation_description, webaddress, emailaddress, phonenumber, area
`

type UpdateAccommodationParams struct {
	ID                int64  `db:"id"`
	AccommodationName string `db:"accommodation_name"`
	Pernight          int64  `db:"pernight"`
	AccommodationType int64  `db:"accommodation_type"`
	Webaddress        string `db:"webaddress"`
	Emailaddress      string `db:"emailaddress"`
	Phonenumber       string `db:"phonenumber"`
	Area              int64  `db:"area"`
}

func (q *Queries) UpdateAccommodation(ctx context.Context, arg UpdateAccommodationParams) (Accommodation, error) {
	row := q.db.QueryRowContext(ctx, updateAccommodation,
		arg.ID,
		arg.AccommodationName,
		arg.Pernight,
		arg.AccommodationType,
		arg.Webaddress,
		arg.Emailaddress,
		arg.Phonenumber,
		arg.Area,
	)
	var i Accommodation
	err := row.Scan(
		&i.ID,
		&i.AccommodationName,
		&i.Pernight,
		&i.AccommodationType,
		&i.AccommodationDescription,
		&i.Webaddress,
		&i.Emailaddress,
		&i.Phonenumber,
		&i.Area,
	)
	return i, err
}
